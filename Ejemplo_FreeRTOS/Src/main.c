/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/*
 * Microcontroller: STM32F439ZI
 * */

/*
 * Este proyecto utiliza */
#include "Config.h"
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "task.h"

#define QUEUE false // Habilitar ejemplo entre interrupción con Colas (true) y sin ellas (false)
#define DEFERRED_TASK true // Habilitar tarea diferida
#define SEMA false // Habilitar Semaforo binario
#define MUTEX false // Habilitar Mutex
#define TIMER false // Habilitar TIMER

void Error_Message(char const * message)
{
	Usart_Transmit(message, false);
	while (1) __asm volatile("nop");
}

#if QUEUE
#include "queue.h"
QueueHandle_t Queue_from_UsartISR = (void*)0;
#else
char arrayDataReceive[1];
char * ptrDataReceive = arrayDataReceive;
#endif
void USART3_IRQHandler(void)
{
	if ( (USART3->SR & RIF) )
	{
#if QUEUE
		char ReadData = USART3->DR;
		xQueueSendFromISR(Queue_from_UsartISR, &ReadData, (void*)0);
		return;
#else
		*ptrDataReceive = USART3->DR;
		return;
#endif
	}else if( (USART3->SR & TIF) && (*ptrDataTransmit == '\0') )
	{
		USART3->CR1	&= ~USART_CR1_TXEIE;
		ptrDataTransmit = (void *)0;
		return;

	}else if( (USART3->SR & TIF) && (*ptrDataTransmit != '\0') ) USART3->DR = *ptrDataTransmit++;

}

static void Task_USART()
{
#if QUEUE
	char ReadFromQueue_USART3;

	while(1)
		if (xQueueReceive(Queue_from_UsartISR, &ReadFromQueue_USART3, portMAX_DELAY) == pdPASS)
			if ( ReadFromQueue_USART3 == 'A' )
			{
				ReadFromQueue_USART3 = 0;
				Usart_Transmit("\tRecibi una A desde una cola\r\n\n", true);
				vTaskDelay( pdMS_TO_TICKS(500) );
			}

#else
	while (1)
		if( *ptrDataReceive == 'A' )
		{
			*ptrDataReceive = 0;
			Usart_Transmit("\r\nRecibi una A desde ISR\r\n", true);
			vTaskDelay( pdMS_TO_TICKS(500) );
		}

#endif
}

#if DEFERRED_TASK
TaskHandle_t PushTaskHandle = (void *)0;

void EXTI15_10_IRQHandler(void)
{
	EXTI->PR |= EXTI_PR_PR13;

	BaseType_t xHigherPriorityTaskWoken = pdTRUE;
	vTaskNotifyGiveFromISR(PushTaskHandle, &xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR( xHigherPriorityTaskWoken ); //xHigherPriorityTaskWoken = pdFALSE, desprecia esta función

}

static void Task_PUSH()
{
	GpioConfig_TaskPush();

	while(1)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		LEDGREEN_Blink();
		Usart_Transmit("\r\n\nLED 0 parpadeando\r\n\n", true);
	}
}
#endif

#if SEMA | MUTEX
#include "semphr.h"
#endif

#if SEMA
SemaphoreHandle_t xSemaphore;

void EXTI1_IRQHandler(void)
{
	EXTI->PR |= EXTI_PR_PR1;

	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    xSemaphoreGiveFromISR(xSemaphore, &xHigherPriorityTaskWoken);
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken); //xHigherPriorityTaskWoken = pdFALSE, desprecia esta función

}

static void Task_LEDBLUE()
{
	GpioConfig_TaskLedBlue();

	while(1)
	{
		vTaskDelay( pdMS_TO_TICKS(1000) );
		EXTI->SWIER |= EXTI_SWIER_SWIER1;
		if (xSemaphoreTake(xSemaphore, portMAX_DELAY) == pdPASS) LEDBLUE_Blink();
	}

}
#endif

#if MUTEX
SemaphoreHandle_t xMutex;

static void Task_LEDRED1()
{
	while(1)
	{
		if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdPASS)
		{
			LEDRED_BlinkUp();
			vTaskDelay( pdMS_TO_TICKS(500) );
			xSemaphoreGive(xMutex);
		}

		 vTaskDelay(pdMS_TO_TICKS(100));  // Tiempo entre intentos
	}
}

static void Task_LEDRED2()
{
	while(1)
	{
		if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdPASS)
		{
			LEDRED_BlinkDown();
			vTaskDelay( pdMS_TO_TICKS(500) );
			xSemaphoreGive(xMutex);
		}
		 vTaskDelay(pdMS_TO_TICKS(100));  // Tiempo entre intentos
	}
}
#endif

#if TIMER
#include "timers.h"

/*
 * No es una tarea.
 * Es una ISR propia de FreeRTOS,
 * por lo tanto,
 * queda prohibido utilizar: vTaskDelay( pdMS_TO_TICKS(time_ms) ) */
TimerHandle_t xTimer;
void vTimerCallbackLED1(TimerHandle_t xTimer) //Otro nombre: Demmon task
{
	LEDGREEN_Blink();
}

#endif

int main(void)
{
	ConfigClock();
	UsartConfig();

#if DEFERRED_TASK | TIMER
	GpioConfig_TaskGreen();
#endif

#if QUEUE
    Queue_from_UsartISR = xQueueCreate(1, sizeof(char));
    configASSERT(Queue_from_UsartISR != (void *)0);

#endif

#if DEFERRED_TASK
    xTaskCreate(Task_PUSH, "TaskPUSH", configMINIMAL_STACK_SIZE, (void *)0, tskIDLE_PRIORITY + 1, &PushTaskHandle);
#endif

#if SEMA
    xSemaphore = xSemaphoreCreateBinary();
    if (xSemaphore != (void *)0) xTaskCreate(Task_LEDBLUE, "TaskLedUno", configMINIMAL_STACK_SIZE, (void *)0, tskIDLE_PRIORITY + 2, (void *)0);

    else Error_Message("\r\n\nERROR: Cola no creada.");

#endif

#if MUTEX
    GpioConfig_TaskLedRed();
    xMutex = xSemaphoreCreateMutex();

    if (xMutex != (void*)0)
    {
    	xTaskCreate(Task_LEDRED1, "TaskLEDRED1", configMINIMAL_STACK_SIZE, (void *)0, tskIDLE_PRIORITY, (void *)0);
    	xTaskCreate(Task_LEDRED2, "TaskLEDRED2", configMINIMAL_STACK_SIZE, (void *)0, tskIDLE_PRIORITY, (void *)0);

    }else Error_Message("\r\n\nERROR: LUTEX no creado.");

#endif

#if TIMER //No es una tarea
    xTimer = xTimerCreate("Timer1", pdMS_TO_TICKS(9999), pdTRUE, (void *)0, vTimerCallbackLED1);

    if (xTimer != (void*)0)
    {
    	Usart_Transmit("\r\nTIMER Creado con exito.\r\n", false);
    	xTimerStart(xTimer, 0);
    }

    else Error_Message("\r\n\nERROR: TIMER no creado.");

#endif

    xTaskCreate(Task_USART, "TaskUSART", configMINIMAL_STACK_SIZE, (void *)0, tskIDLE_PRIORITY, (void *)0);

    Usart_Transmit("\nVa a iniciar el RTOS\r\n", false);
	vTaskStartScheduler();

	/* Loop forever */
	Error_Message("\r\n\nERROR: No debería llegar hasta aquí.");
}
